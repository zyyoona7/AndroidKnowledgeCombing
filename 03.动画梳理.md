## 动画梳理

#### 1. 补间动画和属性动画的区别、补间动画的原理

### 1. Android 中动画的分类

- 视图动画（View Animation）
  - 补间动画（Tween Animation）
  - 帧动画（Frame Animation）
- 属性动画（Property Animation）

### 2. 补间动画介绍

官方对补间动画的详细[介绍](https://developer.android.com/guide/topics/graphics/view-animation)，其中最重要的要数最后一段的注意事项，

> **Note:** Regardless of how your animation may move or resize, the bounds of the View that holds your animation will not automatically adjust to accommodate it. Even so, the animation will still be drawn beyond the bounds of its View and will not be clipped. However, clipping *will occur* if the animation exceeds the bounds of the parent View.
>
> //翻译过来
>
> 注意：无论动画如何移动或调整大小，保持动画的视图边界都不会自动调整以适应它。 即便如此，动画仍将被绘制超出其视图的范围，并且不会被剪裁。 但是，如果动画超出父视图的边界，将发生剪切。

看了这段说明一定要记住，补间动画无论怎么改变当前 View 的边界是不会改变的，也就是说 View 的位置是没有任何变化的，所以面试的时候一般都会问：补间动画的时候点击事件在那个位置？答：在初始位置。

**补间动画内部是如何实现的？它是怎么做到视觉上发生了变化但实际上没变化的？**

**答：因为补间动画内部是通过 Matrix 来改变 View 的平移、旋转等特征的，所以位置不会变化**

#### 补间动画源码流程分析

**注意：以下代码是基于 Android P **

先来一个最简单的平移动画：

```kotlin
private fun translateByTweenAnim(view: View){
 	  val translateAnimation=TranslateAnimation(0f,0f,0f,300f)
    translateAnimation.duration=500
    view.startAnimation(translateAnimation)
}
```

接下来我们进入 `View.startAnimation()` 方法的源码：

```java
/**
 * Start the specified animation now.
 *
 * @param animation the animation to start now
 */
public void startAnimation(Animation animation) {
    animation.setStartTime(Animation.START_ON_FIRST_FRAME);
    setAnimation(animation);
    //方法说明：Used to indicate that the parent of this view should clear its caches.
    //用于指示此视图的父级应清除其缓存。
    invalidateParentCaches();
    //触发重绘 这个方法和调用 invalidate() 方法一样，因为 invalidate() 方法内部也是这样调用的
    invalidate(true);
}
```

既然触发了重绘，那我们就去绘制里面找到关于 Animation 的代码，由于 `View.onDraw()` 是什么都没有，所以我们需要去 `draw()` 方法中寻找：

```java
boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
    //...省略
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        //这个方法内部调用了 Animation 的 getTransformation() 三个参数的方法
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
      //...省略
    }
    //...省略
    //如果 Animation!=null 那么这个 transformToApply 也不为 null
    //然后将一些 Matrix 的改变应用到 renderNode 中
    if (transformToApply != null
            || alpha < 1
            || !hasIdentityMatrix()
            || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;

            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }

            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }

                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }

            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }

        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(),
                                multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    //...省略
}
```

上面的 `draw()` 方法贴出来的部分简单的概括就是，判断当前 View 是否存在 Animation，如果存在则获取到 Transformation 将改变应用到 renderNode 中，那么 Transformation 和 Animation 又是什么关系呢？我们来看一下 Animation 中的关键代码：

```java
/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A transformation object that is provided by the
 *        caller and will be filled in by the animation.
 * @param scale Scaling factor to apply to any inputs to the transform operation, such
 *        pivot points being rotated or scaled around.
 * @return True if the animation is still running
 */
public boolean getTransformation(long currentTime, Transformation outTransformation,
        float scale) {
    mScaleFactor = scale;
    return getTransformation(currentTime, outTransformation);
}

/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A transformation object that is provided by the
 *        caller and will be filled in by the animation.
 * @return True if the animation is still running
 */
public boolean getTransformation(long currentTime, Transformation outTransformation) {
    if (mStartTime == -1) {
        mStartTime = currentTime;
    }

    final long startOffset = getStartOffset();
    final long duration = mDuration;
    float normalizedTime;
    if (duration != 0) {
        normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) /
                (float) duration;
    } else {
        // time is a step-change with a zero duration
        normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
    }

    final boolean expired = normalizedTime >= 1.0f || isCanceled();
    mMore = !expired;

    if (!mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);

    if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
        if (!mStarted) {
            fireAnimationStart();
            mStarted = true;
            if (NoImagePreloadHolder.USE_CLOSEGUARD) {
                guard.open("cancel or detach or getTransformation");
            }
        }

        if (mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);

        if (mCycleFlip) {
            normalizedTime = 1.0f - normalizedTime;
        }

        final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
        //此处调用 applyTransformation
        applyTransformation(interpolatedTime, outTransformation);
    }

    if (expired) {
        if (mRepeatCount == mRepeated || isCanceled()) {
            if (!mEnded) {
                mEnded = true;
                guard.close();
                fireAnimationEnd();
            }
        } else {
            if (mRepeatCount > 0) {
                mRepeated++;
            }

            if (mRepeatMode == REVERSE) {
                mCycleFlip = !mCycleFlip;
            }

            mStartTime = -1;
            mMore = true;

            fireAnimationRepeat();
        }
    }

    if (!mMore && mOneMoreTime) {
        mOneMoreTime = false;
        return true;
    }

    return mMore;
}

/**
 * Helper for getTransformation. Subclasses should implement this to apply
 * their transforms given an interpolation value.  Implementations of this
 * method should always replace the specified Transformation or document
 * they are doing otherwise.
 *
 * @param interpolatedTime The value of the normalized time (0.0 to 1.0)
 *        after it has been run through the interpolation function.
 * @param t The Transformation object to fill in with the current
 *        transforms.
 */
protected void applyTransformation(float interpolatedTime, Transformation t) {
}
```

这是 Animation 中三个方法的调用关系，而所有的补间动画 TranslateAnimation、ScaleAnimation、RotateAnimation、AlphaAnimation 都重写了 `applyTransformation()` 方法，因为上面我们的动画示例是 TanslateAnimation 所以接下来我们来看一下 TranslateAnimation 中的 `applyTransformation()` 方法实现：

```java
@Override
protected void applyTransformation(float interpolatedTime, Transformation t) {
    float dx = mFromXDelta;
    float dy = mFromYDelta;
    if (mFromXDelta != mToXDelta) {
        dx = mFromXDelta + ((mToXDelta - mFromXDelta) * interpolatedTime);
    }
    if (mFromYDelta != mToYDelta) {
        dy = mFromYDelta + ((mToYDelta - mFromYDelta) * interpolatedTime);
    }
    t.getMatrix().setTranslate(dx, dy);
}
```

可以看到 `applyTransformation()` 方法中修改了 Transformation 中的 Matrix，这样就连城了一个环。

**看完了源码我们来总结一下，就是补间动画是通过不断地修改 Matrix 来实现的绘制的位置变化，但是整个流程中没有修改和 View 的边界以及位置相关的属性，而 View 的事件分发（具体看事件分发梳理文章），是通过子 View 的左上右下等位置来判断当前触摸事件落在了哪个子 View 内，所以补间动画点击事件在起始位置响应。**

### 3. 属性动画介绍

属性动画是怎么改变 View 的位置的？