## Handler 机制知识梳理

### 1. Handler 机制简介

Handler 机制是 Android 中的消息传递机制，用于线程间的消息传递。日常使用主要场景：子线程处理耗时任务，通过 Handler 通知 UI 线程更新状态。

**相关的 Handler 应用：HandlerThread、AsyncTask**

### 2. Handler 使用

首先创建一个 MainHandler 类继承 Handler：

```kotlin
private class MainHandler constructor(activity: HandlerActivity) : Handler() {

    val reference: WeakReference<HandlerActivity?> = WeakReference(activity)

    override fun handleMessage(msg: Message?) {
        super.handleMessage(msg)
        reference.get()?.handleMessage(msg)
    }
}
```

然后在 Activity 的 `onCreate()` 方法中实例化：

```kotlin
    private lateinit var mainHandler: Handler

    override fun onCreate(savedInstanceState: Bundle?) {
        mainHandler = MainHandler(this)
    }
```

然后模拟一个耗时操作：

```kotlin
    override fun initListeners(savedInstanceState: Bundle?) {
        //点击事件
        binding.btnNormal1.setOnClickListener {
            //开启一个线程模拟耗时操作
            doNormalHandlerTask()
        }
    }

    private fun doNormalHandlerTask() {
        Thread {
            //休眠来模拟耗时操作
            try {
                Thread.sleep(1000)
            } catch (e: InterruptedException) {
                e.printStackTrace()
            }
            val msg = Message.obtain()
            msg.what = MSG_NORMAL_1
            //使用 sendMessage() 方法发送消息
            mainHandler.sendMessage(msg)
        }.start()
    }

    //MainHandler 的 handleMessage() 方法调用此方法
    private fun handleMessage(msg: Message?) {
        when (msg?.what ?: -1) {
            MSG_NORMAL_1 -> {
                callNormal1()
            }
            else -> {
            }
        }
    }

    private fun callNormal1() {
        Toast.makeText(this, "normal1 execute.", Toast.LENGTH_SHORT).show()
        Log.d(TAG,"current thread:${Thread.currentThread()}")
    }

//Logcat 输出结果：
D/HandlerActivity: current thread:Thread[main,5,main]
```

这是一个非常常规的 Handler 的使用，我们看到了最后的输出结果 `callNormal1()` 方法是在主线程执行的，这就实现了从 Thread 线程到主线程的消息传递，那么到底消息是怎么传递的呢？我们来通过源码去寻找答案。

### 3. Handler 源码分析

**注意：以下源码来自于 Android 9.0**

首先我们从 Handler 类的构造方法入手：

```java
    /**
     * Default constructor associates this handler with the {@link Looper} for the
     * current thread.
     *
     * If this thread does not have a looper, this handler won't be able to receive messages
     * so an exception is thrown.
     */
    public Handler() {
        this(null, false);
    }

    /**
     * Use the {@link Looper} for the current thread with the specified callback interface
     * and set whether the handler should be asynchronous.
     *
     * Handlers are synchronous by default unless this constructor is used to make
     * one that is strictly asynchronous.
     *
     * Asynchronous messages represent interrupts or 
     * events that do not require global ordering
     * with respect to synchronous messages.  Asynchronous messages are not subject to
     * the synchronization barriers introduced by 
     * {@link MessageQueue#enqueueSyncBarrier(long)}.
     *
     * @param callback The callback interface in which to handle messages, or null.
     * @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for
     * each {@link Message} that is sent to it or {@link Runnable} that is posted to it.
     *
     * @hide
     */
    public Handler(Callback callback, boolean async) {
        //这里是一个检查可能内存泄漏的一个提示
        if (FIND_POTENTIAL_LEAKS) {
            final Class<? extends Handler> klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() 
                 || klass.isLocalClass()) &&
                    (klass.getModifiers() & Modifier.STATIC) == 0) {
              Log.w(TAG, "The following Handler class should be static or "
                    +"leaks might occur:" + klass.getCanonicalName());
            }
        }
				//获取当前线程的 Looper 对象
        mLooper = Looper.myLooper();
        //如果 Looper 为 null 则抛出异常
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread " + Thread.currentThread()
                        + " that has not called Looper.prepare()");
        }
        //保存 Looper 内的 mQueue 对象，这里 mQueue 为 MessageQueue 类型
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
```



#### 3. Handler 怎么用，在 Android 中有哪些用了 Handler

[Handler 问题文章](https://juejin.im/entry/5b2fbb0ae51d4558a75e8a59)

[Handler 机制的作用](https://blog.csdn.net/carson_ho/article/details/80175876)